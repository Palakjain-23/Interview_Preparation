--------------------[Trees]---------------------
They are the hierarchical datastructure that consists of nodes that are connected via edges. Such that their exists only one path between two nodes. 

Types of Trees
    1. Binary tree
       It is a tree that can have maximum of two child.
       
       Types :
       
       1.1 Full Binary Tree
           A full binary tree is a binary tree with either zero or two child nodes for each node. 

       1.2 Complete Binary Tree
            A complete binary tree is a binary tree in which all the levels of the tree are filled expect the last level in which element are to be filled from left

       1.3 Perfect Binary Tree
            It can be said that each level of the tree is completely filled by the nodes.

       1.4 Balance Binary Tree
            is a binary tree in which the height of the left subtree and right subtree of any node does not differ by more than 1

       1.5 Degenerate Binary Tree
           It is Binary tree in which all internal level have only one child.           


    2. Tenary tree   
        It is a tree that can have maximum of three child.

    3. N-ary tree
        It is a tree that can have any number of child.
        Every node contains the adresses of its children and first node address is stored in root.
        Number of children is known in advance 

-----Avl TREE
        AVL tree is a self-balancing Binary Search Tree (BST) where the difference between heights of left and right subtrees for any node cannot be more than one.


    TREE traversal~~~
    
#include <iostream>
using namespace std;

class Node {
public:
    int element;
    Node* left;
    Node* right;

    Node(int val) {
        element = val;
        left = NULL;
        right = NULL;
    }
};

class BinaryTree {
private:
    Node* root;

    void traversePreorder(Node* node) {
        if (node == NULL)
            return;
        cout << " " << node->element << " ";
        traversePreorder(node->left);
        traversePreorder(node->right);
    }

    void traverseInorder(Node* node) {
        if (node == NULL)
            return;
        traverseInorder(node->left);
        cout << " " << node->element << " ";
        traverseInorder(node->right);
    }

    void traversePostorder(Node* node) {
        if (node == NULL)
            return;
        traversePostorder(node->left);
        traversePostorder(node->right);
        cout << " " << node->element << " ";
    }

public:
    BinaryTree() {
        root = NULL;
    }

    void insert(int val) {
        if (root == NULL) {
            root = new Node(val);
        } else {
            insert(root, val);
        }
    }

    void insert(Node* node, int val) {
        if (val < node->element) {
            if (node->left == NULL) {
                node->left = new Node(val);
            } else {
                insert(node->left, val);
            }
        } else {
            if (node->right == NULL) {
                node->right = new Node(val);
            } else {
                insert(node->right, val);
            }
        }
    }

    void traversePreorder() {
        traversePreorder(root);
    }

    void traverseInorder() {
        traverseInorder(root);
    }

    void traversePostorder() {
        traversePostorder(root);
    }
};

int main() {
    BinaryTree tree;
    tree.insert(36);
    tree.insert(26);
    tree.insert(46);
    tree.insert(21);
    tree.insert(31);
    tree.insert(11);
    tree.insert(24);
    tree.insert(41);
    tree.insert(56);
    tree.insert(51);
    tree.insert(66);

    cout << "\n The Preorder traversal of given binary tree is -\n";
    tree.traversePreorder();

    cout << "\n The Inorder traversal of given binary tree is -\n";
    tree.traverseInorder();

    cout << "\n The Postorder traversal of given binary tree is -\n";
    tree.traversePostorder();

    return 0;
}
